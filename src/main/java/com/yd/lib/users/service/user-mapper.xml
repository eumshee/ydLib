<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.yd.lib.users.serviceImpl.user-mapper">
	
	<select id="loginCheck" parameterType="com.yd.lib.users.vo.UsersVO" resultType="com.yd.lib.users.vo.UsersVO" >
		select * from users where user_id = #{user_Id} and user_pw = #{user_Pw} and not user_Gubun = '삭제 회원'
	</select>
	
	<insert id="userJoin" parameterType="hashmap" >
		insert into users values(#{user_Id},#{user_Name},#{user_Pw},'준회원',#{user_Gender},#{user_Birth},#{user_Phone},#{user_Addr},#{user_Email})
	</insert>
	
	
	<select id="emailCheck" parameterType="string" resultType="com.yd.lib.users.vo.UsersVO" >
		select * from users where user_email = #{p}
	</select>
	
	<select id="telCheck" parameterType="string" resultType="com.yd.lib.users.vo.UsersVO" >
		select * from users where user_phone = #{p}
	</select>
	
	<select id="idCheck" parameterType="string" resultType="com.yd.lib.users.vo.UsersVO" >
		select * from users where user_id = #{p}
	</select>


	<update id="userPwUpdate" parameterType="hashmap">
		update users set user_pw=#{user_Pw} where user_id=#{user_Id}
	</update>
	
	<update id="userEmailUpdate" parameterType="hashmap">
		update users set user_Email=#{user_Email} where user_Id=#{user_Id}
	</update>
	
	<update id="userPhoneUpdate" parameterType="hashmap">
		update users set user_Phone=#{user_Phone} where user_Id=#{user_Id}
	</update>
	
	<update id="userAddrUpdate" parameterType="hashmap">
		update users set user_Addr=#{user_Addr} where user_Id=#{user_Id}
	</update>
	
	
	
	
	<select id="newBook" parameterType="com.yd.lib.book.vo.BookVO" resultType="com.yd.lib.book.vo.BookVO">
		SELECT b.book_title, b.book_aut, b.book_location, h.loan_date, h.return_date, h.loan_status  
				from users u join history h on (u.user_id = h.user_id)
				join book b on (b.book_num = h.book_num);
	</select>
	
	<select id="newBookPaging" parameterType="com.yd.lib.book.vo.BookVO" resultType="com.yd.lib.book.vo.BookVO">
		select b.*
		from(
			 select rownum rn , a.*
			 from (
				   select * from (
                                  SELECT ROW_NUMBER() OVER(PARTITION BY b1.book_isbn ORDER BY b1.book_num DESC ) AS RNUM, b1.* , b2.all_book_cnt , NVL(b3.can_book_cnt,0) as can_book_cnt
                                  FROM book b1 
                                  join (
                                  		select book_isbn , COUNT(book_isbn) as all_book_cnt
										from book
										GROUP BY book_isbn
										) b2
                                  on b1.book_isbn = b2.book_isbn
                                  full join (
											 select  book_isbn , count(book_isbn) as can_book_cnt
											 from book
											 where book_byn = 'Y'
											 group by book_isbn
                                  ) b3
                                  on b1.book_isbn = b3.book_isbn
                                  where book_indate > sysdate - 30
                                  )bk
                where RNUM = 1
                order by
                <choose>
        			<otherwise>book_indate asc</otherwise>
    			</choose>
                ) a
			 )b
		where rn between #{firstCnt} and #{lastCnt}
	</select>
	
	
</mapper>